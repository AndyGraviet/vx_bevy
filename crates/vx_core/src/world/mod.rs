use bevy::{prelude::*, utils::HashMap};
use building_blocks::{
    core::{Extent3i, PointN},
    storage::Array3x1,
};
use heron::{CollisionShape, RigidBody};
use std::collections::VecDeque;

mod meshing;
mod world;
mod worldgen;

mod coords;
pub use coords::*;

pub const CHUNK_HEIGHT: i32 = 128;
pub const CHUNK_WIDTH: i32 = 16;
pub const CHUNK_DEPTH: i32 = 16;

pub type ChunkEntityMap = HashMap<IVec2, Entity>;
pub type WorldChunkMap = HashMap<IVec2, Array3x1<crate::voxel::Voxel>>;

/// A component tracking the current loading state of a chunk.
pub enum ChunkLoadState {
    Load,   // Chunk needs to be loaded from disk.
    Unload, // Chunk needs to be saved to disk and unloaded.
    //Despawn, // Chunk will be despawned on next frame.
    Generate, // Chunk wasn't generated beforehand and needs to be generated by the worldgen.
    Done,     // Chunk is done loading.
}

pub(crate) struct ChunkSpawnRequest(IVec2);
pub(crate) struct ChunkDespawnRequest(IVec2, Entity);

pub(crate) struct ChunkLoadRequest(Entity);

/// An event signaling that a chunk and its data have finished loading and are ready to be displayed.
pub struct ChunkReadyEvent(pub IVec2, pub Entity);

/// A component describing a chunk.
pub struct ChunkInfo {
    pub pos: IVec2
}

#[derive(Bundle)]
pub struct ChunkDataBundle {
    pub transform: Transform,
    pub global_transform: GlobalTransform,
    pub chunk_info: ChunkInfo,
    pub mesh_info: ChunkMeshInfo,
    pub rigid_body: RigidBody,
    pub collision_shape: CollisionShape,
}

pub struct ChunkMeshInfo {
    pub fluid_mesh: Handle<Mesh>,
    pub chunk_mesh: Handle<Mesh>,
}

#[inline]
pub fn chunk_extent() -> Extent3i {
    Extent3i::from_min_and_shape(
        PointN([0; 3]),
        PointN([CHUNK_WIDTH, CHUNK_HEIGHT, CHUNK_DEPTH]),
    )
}

pub struct WorldSimulationPlugin;

impl Plugin for WorldSimulationPlugin {
    fn build(&self, app: &mut AppBuilder) {
        app.init_resource::<ChunkEntityMap>()
            .init_resource::<WorldChunkMap>()
            .init_resource::<VecDeque<ChunkLoadRequest>>()
            //todo: move this to a struct or smth else
            .init_resource::<worldgen::NoiseTerrainGenerator>()
            // internal events
            .add_event::<ChunkSpawnRequest>()
            .add_event::<ChunkDespawnRequest>()
            .init_resource::<VecDeque<meshing::ChunkMeshingRequest>>()
            // public events
            .add_event::<ChunkReadyEvent>()
            // systems
            .add_system(world::update_visible_chunks.system())
            .add_system(world::create_chunks.system())
            .add_system(world::load_chunk_data.system())
            .add_system(world::generate_chunks.system())
            .add_system(world::prepare_for_unload.system())
            .add_system(world::mark_chunks_ready.system())
            .add_system(world::destroy_chunks.system())
            .add_system(meshing::handle_chunk_ready_events.system())
            .add_system(meshing::mesh_chunks.system());
    }
}
